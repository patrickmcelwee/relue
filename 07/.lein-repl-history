(defn isPrime [number]
  (!= (mod number 2) 0)
  )
(defn isPrime [number]
  (!= (mod number 2) 0)
  )
(defn isPrime [number]
  (not (= (mod number 2) 0))
  )
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(defn isPrime
  ([number primes]
   (not (= (mod number 2) 0))
   )
  ([number]
   (isPrime number [])
   )
  )
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(defn notDivisible [dividend divisor]
  (not (= (mod dividend divisor) 0))
  )
(defn isPrime [number]
  (every? notDivisible [number (range 2 (sqrt number))]
    )
  )
(ns prime_finder.core
  (:use clojure.math.numeric-tower)
  )
(in-ns prime_finder.core
  (:use clojure.math.numeric-tower)
  )
(ns prime_finder.core
  (:use clojure.math.numeric-tower)
  )
(ns prime_finder.core
  (:use clojure.math.numeric-tower)
  )
(require 'clojure.math.numeric-tower)
exit
(require 'clojure.math.numeric-tower :as math)
(require '[clojure.math.numeric-tower :as math])
exit
(require '[clojure.math.numeric-tower :as math])
(defn notDivisible [dividend divisor]
  (not (= (mod dividend divisor) 0))
  )
(defn isPrime [number]
  (every? notDivisible [number (range 2 (sqrt number))]
    )
  )
(defn notDivisible [dividend divisor]
  (not (= (mod dividend divisor) 0))
  )
(defn isPrime [number]
  (every? notDivisible [number (range 2 (sqrt number))]
    )
  )
(defn notDivisible [dividend divisor]
  (not (= (mod dividend divisor) 0))
  )
(defn isPrime [number]
  (every? notDivisible [number (range 2 (math/sqrt number))]
    )
  )
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(defn notDivisible [dividend divisor]
  (not (= (mod dividend divisor) 0))
  )
(defn isPrime [number]
  (every? notDivisible number (range 2 (math/sqrt number))
    )
  )
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(defn notDivisible [dividend divisor]
  (not (= (mod dividend divisor) 0))
  )
(defn isPrime [number]
  (every? #(notDivisible number %) (range 2 (math/sqrt number))
    )
  )
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(math/sqrt 9)
(range 2 3)
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(defn notDivisible [dividend divisor]
  (not (= (mod dividend divisor) 0))
  )
(defn isPrime [number]
  (every? #(notDivisible number %) (range 2 (+ 1 (math/sqrt number)))
    )
  )
(defn notDivisible [dividend divisor]
  (not (= (mod dividend divisor) 0))
  )
(defn isPrime [number]
  (every? #(notDivisible number %) (range 2 (+ 1 (math/sqrt number)))
    )
  )
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(defn primes []
  (filter isPrime range))
(take 5 primes)
(take 5 (primes))
(defn primes []
  (filter isPrime (range)))
(take 5 (primes))
(defn isPrime [number]
  (if (< number 4)
    true
    (every? #(notDivisible number %) (range 2 (+ 1 (math/sqrt number)))))
    )
(take 5 (primes))
(defn nth-prime [n]
  (nth primes n)
  )
(defn nth-prime [n]
  (nth primes n)
  )
(nth-prime 1)
(defn nth-prime [n]
  (nth (primes) n)
  )
(nth-prime 1)
(defn isPrime [number]
  (if (< number 2)
    false
    (every? #(notDivisible number %) (range 2 (+ 1 (math/sqrt number)))))
    )
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(defn isPrime [number]
  (if (< number 2)
    false
    (if (= number 2)
      true
      (every? #(notDivisible number %) (range 2 (+ 1 (math/sqrt number)))))
      )
    )
(isPrime 1)
(isPrime 2)
(isPrime 3)
(isPrime 4)
(isPrime 5)
(isPrime 6)
(isPrime 7)
(isPrime 8)
(isPrime 9)
(nth-prime 1)
(nth-prime 10001)
(defn nth-prime [n]
  (nth (primes) (- n 1))
  )
(time (nth-prime 10001))
exit
(require '[clojure.math.numeric-tower :as math]
         '[clojure.core.reducers :as r]
         )
(defn notDivisible [dividend divisor]
  (not ( = (mod dividend divisor) 0)))
(defn isPrime [number]
  (if ( < number 2)
    false
    (if ( = number 2)
      true
      (every? #(notDivisible number %) (range 2 (+ 1 (math/sqrt number)))))))
(defn primes [] (r/filter isPrime (range)))
(defn nth-prime [n]
  (nth (primes) (- n 1)))
(time (nth-prime 10001))
(defn nth-prime [n]
  (nth (into [] (primes)) (- n 1)))
(time (nth-prime 10001))
(defn nth-prime [n]
  (nth (into [] (take n (primes))) (- n 1)))
(time (nth-prime 10001))
